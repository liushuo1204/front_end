# JavaScript

前端学习资料，包括 JavaScript 基础、JavaScript 进阶、ES6 语法、正则表达式、前端框架、等。

# 面试题

## Ⅰ、HTML+CSS

### ^一、说一下哪些是块级元素？哪些是行块级元素？哪些是行级元素？

1、块级元素：

①、h1 - h6：标题标签

②、p：段落标签

③、hr：水平线标签

④、ul + li：无序列表

⑤、ol + li：有序列表

⑥、dl + dt / dd：自定义 列表

⑦、div：布局容器

⑧、table：表格

⑨、from：表单

2、行块级元素：

①、input：表单元素

②、img：图片标签

3、行级元素：

①、a：超链接

②、span：修饰文本标签

③、strong or b：字体加粗

④、em or i：字体倾斜

⑤、ins or u：下划线

⑥、del or s：删除线

⑦、label：表单元素

⑧、sub：下标

⑨、sup：上标

### ^二、src 与 href 的区别？

1、href 表示文件的来源地址，在 link 和 a 标签上使用。href 引用的内容是与页面有关联的引用。

2、src 表示文件的录入地址，在 img 和 script 标签上使用。

### ^三、常用的选择器有哪些？id 和 class 的区别？并说明 css 的优先级。

1、常用的选择器：标签选择器、类名选择器、id 选择器、通配符选择器、序选择器、交集选择器、并集选择器、子代选择器、后代选择器、下一个兄弟选择器

2、id 是唯一的，一个页面只能有一个 id；class 不是唯一的，多个标签可以用相同的类名，一个标签可以用多个类名

3、行内式 > 内嵌式 > 链入式；不同类型的选择器：!important > id 选择器 > 类名选择器 > 标签选择器

### ^四、css 哪些属性是可以被继承的？

1、字体颜色可以被继承

2、以 font 开头的可以被继承

3、以 text 开头的可以被继承

4、以 line 开头的可以被继承

### ^五、什么是盒模型？盒模型的组成。

盒模型从外到内依此是，margin 外边距，border 边框，padding 内边距，内容的宽高

### ^六、清除浮动的方法有哪些？

1、直接给父级添加高度

2、隔墙法，但是不推荐使用，产生多余代码

3、超出隐藏，overflow:hidden

4、公共类，伪类清除。

```css
类名:after {
    /* 伪类元素内容为空 */
    content: "";
    /* 转为块元素 */
    display: block;
    /* 清除左右浮动 */
    clear: both;
}
```

### ^七、div 中不设高度，在里面添加一张图片，box 高度会自动撑开，但是 div 会有 2-4px 像素的误差,怎么解决？(行块元素有 2-4 像素的误差，什么原因造成的？怎么解决？)

1、行块元素垂直对齐基准导致父级产生 2-4 像素误差，行块元素不是绝对垂直居中；

2、解决办法：

方法 1：改变行块元素的垂直居中方式

方法 2：改变他的 display 转为块元素

### ^八、两个宽度为 50%并且边框为 1px 的 div 并排显示（怪异盒子）。

将外边框改为内边框，box-sizing:border-box;

### ^九、说出四种实现水平垂直居中的方式？

1、设置绝对定位四个属性为零，matgin:auto

2、left:50%;margin-left:负数宽度的一半

top:50%;margin-top:负数高度的一般

3、设置绝对定位，

left:50%;top:50%;

transform:translate(-50%,-50%);

4、设置

```css
 {
    display: flex
;
/*水平居中*/
    justify-content: center
;
/*垂直居中*/
    align-items: center
;
}
```

### ^十、说一下定位有几种？有什么区别？

1、相对定位，绝对定位、固定定位。

2、区别：

①、相对定位：以自己为参考点，不脱离标准文档流，原来的位置被保留

②、绝对定位：以距离自己最近的有相对定位的祖辈为参考点，脱离标准文档流，原来的位置不被保留

③、固定定位：以浏览器为参考点，脱离标准文档流，原来的位置不被保留

### ^十一、CSS 画一个三角形？

```css
width:

0
;
height:

0
;
border:

20
px solid

;
border-color:
rgba

(
0
,
0
,
0
,
0
)
rgba

(
0
,
0
,
0
,
0
)
pink
rgba

(
0
,
0
,
0
,
0
)
;
```

实现方式：

设置宽高为 0，然后设置边框为 20px，边框类型为 solid；

上右下左四个边框的颜色，设置其中三个为透明，一个不透明，即可实现三角形

### ^十二、说说你对行高的理解 line-height？

行高是指行与行之间的距离

主要作用单行文本居中:

把高度的值设置为 line-height 值，可以实现单行文本居中，其实也可以把高度删掉。多行文本居中:需要配合 padding 使用

### ^十三、你是怎么处理浏览器的兼容性?

1、书写样式的时候加上浏览器的前缀

-moz- 火狐的前缀

-webkit- 谷歌的前缀

-o- opera

-ms- ie 浏览器

2、降级处理（当前写法不支持，那就换一个相对来说比较 low 的写法）

3、用 js 逻辑处理

### ^十四、h5 新特性？

1、h5 新语义元素

2、新增表单功能

3、本地存储

4、SVG

5、canvas

6、地理定位

### ^十五、CSS3 新特性？

新增表单，属性，相邻兄弟等选择器

新增背景渐变、盒阴影、边框、过渡、平移、旋转、动画、3d 等

### ^十六、什么是页面的回流和重绘？如何避免页面回流和重绘带来的性能问题？

1、回流：当前元素改变了自身的宽高，布局，显示或者隐藏，或者元素内容结构发生了变化，需要重新构建构建页面的时候就是回流；

重绘：重绘是在一个元素的外观被改变，但是没有改变页面的布局的情况下，比如改变了背景颜色，visibilit。

2、解决措施：

①、尽量减少对 DOM 的操作，特别是对频繁操作的元素。

②、避免使用递归，尽量使用循环。

③、使用缓存，尽量避免重复计算。

④、使用 CSS3 的动画和过渡，避免使用 JavaScript 来控制动画。

⑤、尽量使用相对定位，避免使用绝对定位。

⑥、尽量使用轻量级的元素，如 div 和 span，避免使用重量级的元素，如 table 和 form。

⑦、当你要在 JavaScript 中操作 DOM 时，应该尽量避免使用过多的 DOM 操作，特别是对频繁操作的元素。这是因为，每次 DOM
操作都会导致浏览器进行重排和重绘，这会消耗大量的 CPU 资源，导致页面性能下降。

### ^十七、移动端点击事件会有多少秒的延时?什么原因造成的?如何解决?

为了对早期普通网页更好的体验，iphone 设计了双击放大显示的功能--这就是 300ms 延迟的来源：如果用户一次点击后 300ms
内没有其他操作，则认为是个单击行为；否则为双击放大行为。

设置不能缩放：user-scalable=no， 不能缩放就不会有双击缩放操作。
设置显示宽度：width=device-width。

```html

<meta
        name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
/>
```

### ^z 十八、移动端 0.5 像素如何实现？

1、给目标元素添加一个伪元素 before 或者 after，并设置绝对定位，给伪元素添上 1px 的边框。设置伪元素的宽高为目标元素的 2 倍，缩小
0.5 倍，使用 border-box 把 border 包进来

2、给元素添加背景渐变，设置元素的 50%为颜色，50%为透明，高度为 1px

### 十九、浏览器渲染机制

1、DNS解析，获取网站的ip地址

2、浏览器需要和服务器建立连接(tcp/ip)(三次握手)

3、向服务器发送请求(http协议)

4、服务器处理请求，并返回响应(http协议)

5、浏览器将响应的页面渲染

6、断开和服务器的连接(四次挥手)

### 二十、了解盒子哪些模型？

1、标准盒子模型
2、怪异盒子模型

### 二十一、BFC是什么？

1、BFC是块状格式上下文，意思是一块独立渲染且不受外界影响的区域

## Ⅱ、JavaScript

### ^一、什么是 js？js 是单线程还是多线程？

简单的来说 js 就是运行在浏览器中的解释性语言,脚本语言,是单线程

### ^二、数据类型有哪些？怎样判断数据类型？

1、基本数据类型：

①、字符串：string

②、数字：number

③、布尔：boolean

2、复合引用数据类型：

①、对象：object

②、数组：array

③、函数：function

3、特殊数据类型

①、空：null

②、返回值为空：undefined

③、不是一个数字：NaN

4、检测数据类型的方法：

①、检测除数组外的数据类型：typeof

②、检测数组数据类型：Array.isArray()

③、检测不是一个数字：isNaN

### ^三、在 js 中，=、==、===有什么区别？

1、=：表示赋值

2、==：只比较大小，不比较数据类型

3、===：既比较大小，又比较数据类型

### ^四、i++ 和 ++i 的区别？

1、i++：先取 i 的值，作为表达式 i++的结果，然后在对 i 进行+1 【先赋值后加一】

2、++i：先取 i 的值进行+1,然后取 i 的值作为++i 的表达式的结果 【先加一后赋值】

### ^五、while 和 do while 有什么区别？

1、while 是条件成立才执行循环，条件不成立不执行循环

2、do while 是先执行一次循环，再判断条件是否成立，成立则执行循环体，不成立不执行循环体

### ^六、break 和 continue 的区别？

1、break：终止当前循环，看到 break，后面的呢代码就不执行了

2、continue：跳出当前循环，继续执行下一循环

### ^七、九九乘法表

```javascript
for (let i = 1; i < 9; i++) {
    for (let j = 1; j < i; j++) {
        document.write(i + "*" + j + "=" + i * j + " ");
    }
}
```

### ^八、知不知道递归函数？递归函数经常用吗？递归函数的缺点是什么？

1、自己调用自己的函数就是递归函数。

2、公司明文规定禁止使用递归函数。

3、递归函数必须等最后一次的结果出现才能完成逻辑执行，违背了内存管理机制。

### ^九、用过闭包函数吗？什么是闭包函数？闭包函数的优缺点？内存泄漏，js 回收机制？

1、闭包就是能够读取函数内部变量的函数，定义在函数的内部的函数

2、优点：可以在全局重复使用变量并且不会造成变量污染

3、缺点：闭包容易造成内存泄漏，比较消耗内存，内存消耗过多，会导致浏览器很卡。

4、内存泄漏：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。

5、JS 的回收机制：JavaScript 垃圾回收的机制很简单：找出不使用的变量，然后释放掉其占用的内存。js
中最常用的垃圾回收方式就是标记清除。比如在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

### 十、如何避免闭包引起的内存泄漏？哪些操作会造成内存泄漏？

1、如何避免闭包引起的内存泄漏？

①、注意程序逻辑，避免死循环

②、减少不必要的全局变量，在函数最后将不使用的变量赋值为空

③、避免创建过多的对象

2、哪些操作会造成内存泄漏？

①、意外的全局变量

②、脱离 DOM 的元素引用

③、未清除的定时器

④、闭包函数

⑤、console.log

### ^十一、什么是命名函数？匿名函数？递归函数？回调函数？函数表达式？

1、命名函数：有名字的函数

2、匿名函数：没有名字的函数

3、\*递归函数：函数中自己调用自己的函数就是递归函数

4、\*回调函数：被作为参数传递的函数是回调函数，并且可以访问另一个函数内部的变量

5、表达式：带有变量的函数，用变量调用的函数

6、\*构造函数：用 new 关键字来调用的函数就是构造函数

7、\*闭包函数：闭包就是能够读取函数内部变量的函数，定义在函数的内部的函数

### ^十二、for 与 forEach 的区别？

forEach 不能使用 break，forEach 没有返回值。return 返回的是 undefined

### ^十三、什么是全局变量？什么是局部变量

1、全局变量：在函数体外部声明的变量就是全局变量，省略 var 声明的变量也是全局变量。全局变量在函数体内外都可以使用。

2、局部变量：在函数体里面定义的变量叫做局部变量，只能在函数体内部使用，函数体外部不能被使用。

### ^十四、什么是预解析？

在预解析中，变量的提升，只会在当前作用域中提升，提升到当前作用域的最上方。函数的变量只会提到函数作用域的最前方。

### 十五、请说一下数组常用的方法有哪些？

1、push()：添加到数组的最后

2、splice()：删除指定的元素，并在删除的位置添加元素

3、String()、toString()：将数组转为字符串

4、join()：拼接字符串，将数组用什么符号转为字符串

5、split()：将字符串转为数组

6、shift()：删除数组的第一项

7、pop()：删除数组的最后一项

8、unshift()：将内容添加到数组的开头

9、sort()：正序排序，从小到大

10、concat()：合并数组

11、reverse()：反转

12、indexOf()：方法返回数组中第一次出现给定元素的下标，如果不存在则返回 -1

### 十六、请说获取 dom 方法有几种？

1、\*document.getElementById("id 选择器")：获取单个元素

2、document.getElementsByTagName("标签名")：获取的是一组数据，伪数组，注意：s

3、document.getElementByName("name 名称")：获取的是一组数据，伪数组。注意：s

4、document.getElementsByClassName("类名选择器")：获取的是一组数据，伪数组。注意：s

5、\*document.querySelector("选择器")：通过选择器获取单个节点

6、\*document.querySelectorAll("选择器")：通过选择器获取多个节点。伪数组，可以通过下标取值。

7、parentNode：父节点

8、children：子节点

9、兄弟节点、事件委托等

### 十七、dom 操作的方法？

1、appendChild：添加节点到最后

2、insertBefore：在某个位置插入

3、removeChild：删除子节点

4、replaceChild：修改子节点

5、cloneNode：复制克隆节点

### ^十八、获取设置类名的方法？

1、\*className：获取或者设置类名，其中设置的类名会覆盖原来的类名。所以设置类名的时候要把之前的类名也加上

2、.classList.add("")：添加类名

3、.classList.remove("")：移除类名

### ^十九、innerHTML 和 innerText 的区别？

1、相同点：都可以获取或者设置内容

2、不同点：

①、innerHTML：以代码的形式设置/获取内容

②、innerText：以文本的形式设置/获取内容

### ^二十、js 获取或者设置属性的方法

1、通过 dom 进行获取或者设置属性.dom.属性

2、通过 getAttribute()：获取自定义属性

3、通过 setAttribute()：设置自定义属性

### ^二十一、怎样提升浏览器的加载速度

1、文件的外部引入

2、减少冗余代码，将代码进行封装

3、使用事件委托代替 dom 获取，减少 dom 操作

4、图片的懒加载

5、压缩文件

### ^二十二、什么是事件冒泡？怎样阻止事件冒泡？

1、两个 div 两两嵌套，都添加点击事件，我点击里面的 div 的时候，外面的 div 事件也会触发

2、js 中阻止事件冒泡的方法：e.stopPropagation()；jq 中阻止事件冒泡的方法 return false

### ^二十三、事件绑定，解绑的方法

1、addEventListener：事件绑定

2、removeEventListener：事件解绑

### ^二十四、什么是 window 对象？什么是 document 对象？

1、window 对象也就是 BOM，也就是浏览器对象：window 对象封装了窗口标题，工具栏按钮，地址栏，状态栏等等。都是 window
的成员对象。（window 就是 BOM 也就是浏览器）

2、document 对象也就是 DOM，代表的是 html 整个的文档，可以用来访问网页中的所有元素，dom 属于 window 对象的一部分。（document
就是 dom，也就是网页）

### ^二十五、for in 和 for of 有什么区别？for of 为什么遍历对象会报错？

1、for in 遍历数组得到的是索引，遍历对象得到的是属性，不能遍历 map 对象；for of 遍历数组得到的是值，遍历对象会报错。

2、因为没有引入 iterable，需要加上 Object.keys()，Object.values()才能使用，遍历 map 对象得到的是属性和值。

### ^二十六、说一下你对 this 的理解：

1、在浏览器中，在全局范围内，this 指向的是 window

2、在普通函数中，this 指向的是调用者

3、在构造函数中，this 指向的是 new 出来的那个新对象

4、call、apply、bind 中的 this 被强绑定在那个对象中

5、在箭头函数中 this 属于当前所处的最大的对象，而不是执行时的对象。箭头函数没有自己的 this，它的 this
是继承而来；默认指向在定义它时所处的对象（宿主对象），此处指父级作用域，而不是执行时的对象。

### ^二十七、用过深拷贝，浅拷贝吗？深拷贝和浅拷贝的区别？如何实现深拷贝？浅拷贝？JSON 深拷贝的弊端及解决方案。

1、深拷贝：就是 b 复制了 a，当修改 a 的时候，b 不会随着 a 的变化而变化，拥有独立的内存。将数据中的所有数组拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。

2、浅拷贝就是 b 复制了 a，当修改 a 的时候，b 中的子元素不会随着 a 的变化而变化，但是 b 中的子对象中的元素会随着 a
的变化而变化。原数据和复制后的数据的第一层不会改变，第二层或者深层会改变

3、浅拷贝的方法：

①、slice

②、concat

③、es6 剩余运算符

4、深拷贝：

①、JSON.parse()、JSON.stringify()

②、jq 的 extend 方法

③、通过递归去拷贝所有的层级

5、JSON 弊端

①、如果 obj 里面存在时间对象，通过 JSON 方法会导致时间对象变成了字符串。

②、如果 obj 里面有 RegExp、Error 对象，转化后的结果是空对象。

③、如果 obj 里面有函数，undefined，则序列化的结果会把函数，unedfined 丢失。

④、如果 obj 里面有 NaN，Infinity 和-Infinity，则序列化的结果会变成 null。

⑤、JSON.stringify()只能序列化对象的可枚举的自有属性。如果 obj 中的对象是有构造函数生成的，则使用 JSON.parse(JSON.stringify(
obj))深拷贝后，会丢弃对象的 constructor。

⑥、如果对象中存在循环引用的情况也无法正确实现深拷贝。

6、解决：递归实现深拷贝

### ^二十八、什么是面向对象？面向对象的特点？

1、面向对象是一种编程思想，是由属性和方法组成的。

2、面向对象的特点：封装、继承、多态。

### ^二十九、什么是构造函数？构造函数帮我们干了哪两件事？

1、用 new 关键字调用的函数称为构造函数

2、

①、帮我们创建了一个空对象

②、将结果返回出去

### 三十、面向对象的继承方式？

1、call 或 apply 方法

2、原型链 prototype

3、利用空对象作为中介

### ^三十一、什么是异步？什么是同步？

1、同步可以理解为在执行完一个函数或者方法之后，一直到等待系统的返回值或者消息，之后接收到返回值或者消息之后才往下执行其他的命令。具有等待功能。

2、异步，执行完函数或者方法之后，不必等待系统的返回值或者西消息，就可以直接执行下一个命令。不用等待。

### ^三十二、知道 promise 对象吗？promise 有几种状态？什么情况下进入 catch，封装过接口吗？

1、promise 对象，处理异步函数的，就是将异步改为同步执行。

pending（未待定的状态）

fulfilled（成功的状态）

rejected（失败的状态）

2、当状态成功的时候，会进入 then；当状态是失败的时候，会进入 catch

### ^三十三、http 定义？http 的三次握手？

1、http 是一种网络传输协议，浏览器作为 http 客户端通过 url 向 http 服务器发起请求，服务器接收到请求向客户端发送响应信息。

2、三次握手：

①、客户端向服务端发送请求

②、服务端接收到请求需要进行核对操作，发送的请求服务端能不能接收到，如果接收到，就向客户端返回接收到的请求信息

③、客户端拿着服务器返回成功接收到的这个信息再去向服务器发送请求，两者才能建立联系。

### ^三十四、请求的方式有哪些？post 和 get 的区别？

1、delete、put、post、get 等；

2、区别：

（1）安全性问题：

①、get 请求参数会被拼接在地址栏上，信息会暴露

②、post 请求参数不可见

（2）数据传输量：

①、get 有长度限制

②、post 没有

（3）缓存问题：

①、get 数据会被缓存

②、post 不会

### 三十五、常见的状态码：

1、\*200：请求成功

2、301：资源被永久转移到其他 url

3、\*400：客户端你请求语法错误

4、401：发送的请求需要被认证

5、\*403：请求的资源被服务器拒绝

6、\*404：表面服务器无法找到指定的资源

7、\*500：表示服务器在执行请求时发生了错误

8、\*502：服务器网关出现了错误

9、503：服务器处于停机维护状态，现在无法处理请求

### 三十六、创建 ajax 的步骤

1、创建 XHRHttpRequest 对象，也就是创建一个异步调用对象

2、创建一个 http 请求，并指定请求方法（建立连接）

3、发送 http 请求

4、获取返回的数据

### ^三十七、mouseover 与 mouseenter 的区别？

1、mouseover：鼠标指向的时候触发，当鼠标指向被选元素及其后代元素时触发，会产生事件冒泡

2、mouseenter：鼠标指向的时候触发，当鼠标指向被选中元素时触发，不会产生时间冒泡

### ^三十八、什么是防抖？什么是节流？

1、防抖就是多次执行变为最后一次执行，实现函数的防抖：延时器

2、节流就是多次执行变成每隔一段时间执行。实现函数截留的方法：定时器和时间戳

### ^三十九、sessionStorage，localStorage，cookie 的区别？

1、sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页关闭，所有存储的数据也会被清空。

2、localStorage 生命周期是永久的。除非用户手动清除信息，否则这些信息永久存在。

3、cookie 是浏览器与服务器之间来回传递，cookie 浏览器关闭数据一直保存，只在过期时间内有效，可以设置过期时间。cookie 存储数据不能超过
4k，sessionStorage，localStorage 存储的数据可以是 5M，甚至更多。

### ^四十、var、let、const 的区别？

1、var 声明的变量属于全局变量，属于 window，var 声明的变量可以声明多次，可以修改，并且 var 声明的变量存在变量的提升。

2、let 只在块级作用域中使用，即{}，不存在变量提升，let 只能声明一次不能重复定义，let 声明的变量存在暂时性死区。

3、const 声明一个只读常量，声明之后不允许改变，而且必须初始化，const 定义的基本数据是不可以改变的，但是定义的对象或者是数组可以通过下标或者属性来修改

### ^四十一、为什么 const 可以修改对象或者数组？

1、const 指针指向的地址是不可以改变的，但是地址的内容是可以改变的

### ^四十二、es6 中如何实现数组去重？

1、用 new Set(数组)实现去重

### 四十三、怎样将伪数组转为数组？

1、Array.from 或者剩余运算符去将伪数组转成数组
然后用数组的方法去实现逻辑

### 四十四、es6 的新特性

1、新的声明方式

2、解构性赋值，剩余运算符

3、数组的遍历方法 for of，find 等方法

4、箭头函数

5、symbol，set 去重，map 方法，字符串模板，promise，模块化

6、class 和 extends，super 调用父类的方法

### 四十五、谈谈 async/await 的使用方式和场景

1、async 是用来修饰函数的声明，使用 async 修改的函数会变成一个异步函数，可以使用 then 来接受参数

2、await 用来修饰函数的调用，被 await 修改的函数返回一个 promise 异步对象，使用 await 修饰后，就会将 promise
异步对象转换成一个同步操作。其中直接提取 resolve 里面的值。

### 四十六、箭头函数有什么作用及实际应用场景？

1、箭头函数的作用：

①、箭头函数的语法比函数表达式更简洁

②、箭头函数可以解决 this 指向问题。箭头函数不会创建自己的 this，它只会从自己的作用域链向上一层继承 this。

2、箭头函数的使用场景：

①、简单的函数表达式，内部没有 this 引用，没有递归，事件绑定，解绑定。

②、需要调用 this，且 this 指向和上一层作用域链保持一致时。如保证指向 vue 实例对象。

### ^四十七、class 类如何实现继承，简单实现？

子类继承父类——语法：class 子类 extend 父类，在子类的构造方法中使用 super 调用父类的构造方法。

### 四十八、什么是跨域？解决跨域？

1、跨域指的是：浏览器不能执行其它网站的脚本，从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域是由于浏览器的同源策略造成的，是浏览器施加的安全限制

2、解决：

①、设置跨域代理、在 vue 中的 config.js 中设置 proxy 设置

②、jsonp

③、后端处理

④、借调

### ^四十九、事件循环机制

js 是单线程语言，一次只能完成一个任务，如果同时完成多个任务怎么办？js
把任务分为同步和异步任务，把所有的同步放到主线程上去执行，把所有的异步任务方法事件队列里去，当所有的同步任务都执行完之后，去事件队列中看看有没有没有执行的异步任务，如果有，把需要执行的异步任务拉到主线程上去执行，当这个任务执行完后，再去事件队列里看有没有没有完成的任务，如果有，再把主任务拉到主线程去执行，这样就形成了要给事件循环。

### 五十、宏任务和微任务？

浏览器的事件循环（event loop）中分成宏任务和微任务。JS 中分成同步任务和异步任务。

1、宏任务：JS 中主栈执行的大多数任务，例如：定时器，事件绑定，ajax，回调函数，node 中 fs 操作模块等任务就是宏任务。

2、微任务：promise，async/await，process，nextTick 等就是微任务。

### 五十一、图片的懒加载

懒加载也就是延迟加载。有时候一个网页会包含很多的图片，例如：京东、淘宝这些购物网站，商品图片多只又多，页面图片多，加载的图片就多。服务器压力就会很大。不仅影响渲染速度还会浪费带宽。比如一个
1M 大小的图片，并发情况下，达到 1000 并发，即同时有 1000 个人访问，就会产生 1 个 G 的带宽。

### 五十二、懒加载原理

一张图片就是一个<img>标签，浏览器是否发起请求图片是根据<img>的 src
属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给<img>的 src 赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给
src 赋值。

### 五十三、懒加载思路及实现

实现懒加载有四个步骤，如下：

1、加载 loading 图片

2、判断哪些图片要加载【重点】

3、隐形加载图片

4、替换真图片

### 五十四、常用方法

1、转数字：

Number()

2、转字符串：

toStrong()

String()

3、保留两位小数：

toFixed()

4、数组转字符串方法：

String()、toString()、join()

5、字符串转数组：

split()

6、字符截取：

substring()

substr()

7、字符串修改：

replace()

8、json 字符串转 json 对象：

JSON.parse()

9、json 对象转字符串：

JSON.stringify()

10、检测字符串开头：starWith

11、检测字符串结尾：endWith

12、字符串前面填充：padStart()

13、字符串后面填充：padEnd()

## Ⅲ、vue

### ^一、什么是 MVVM，MVC？

1、MVVM

①、M 是 model：指的是后端传递的数据。

②、v 是 view：指的是视图，也就是所看到的页面。

③、vm 是 view model：视图模型。它是连接 view 与 model 的桥梁，主
要处理业务逻辑

2、MVC

①、M：模型

②、V：视图

③、C：控制器，逻辑处理

### ^二、vue 的特点与功能

1、数据的驱动

2、数据的双向绑定

3、组件化开发

### ^三、vue 的双向绑定原理，vue 响应式原理，数据的响应式？

vue 采用的是数据劫持结合发布者订阅的模式，通过 object.defineProperty()来劫持 get、set 方法，在数据发生变化的时候发布给订阅者，触发响应式回调。

### ^四、页面的响应式

媒体查询，检测屏幕在多大尺寸的时候干什么事情

### 五、vue 双向绑定除了 Object 还有什么方法？

用 addEventListener 给元素添加 input 事件，当数据发生变化的时候进行相应的操作

### 六、v-model 底层原理：

实际上是分别利用了 v-bind 用来绑定 value 的值，用 v-on 去绑定 input 标准事件，这时事件用来监听当前输入域内容发生变化的时候来执行一些事情。

### 七、v-model 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后做了两个操作：

1、v-bind 绑定了 value 属性；

2、v-on 指令给当前元素绑定 input 事件。

### 八、vue 中的修饰符有哪些？

1、.stop：阻止事件冒泡

2、.prevent：阻止事件默认行为

3、.number：转为数字

4、.enter：回车时触发

5、.lazy：失去焦点时触发

6、.trim：清除前后空格

7、.once：只触发一次

### 九、vue 中阻止事件冒泡的方法？

1、js 中原生的方法，e.stopPropagation()

2、vue 中的修饰符.stop

### ^十、vue 中阻止默认事件的方法？

1、js 中原生的方法，e.preventDefault()

2、vue 中的修饰符.prevent

### ^十一、什么是生命周期（钩子函数）？生命周期有什么作用？说一下生命周期有哪些？第一次加载页面会触发哪几个生命周期（钩子函数）？

1、生命周期就是 vue 实例从创建到销毁的的过程。

2、生命周期的作用就是可以帮我们在什么时间段干什么事情。

3、生命周期最初有 10 个，废弃了 2 个，还剩下 8 个：

①、beforeCreate：vue 实例创建之前

②、created：vue 实例创建之后

③、beforeMount：vue 实例 dom 加载之前

④、mounted：vue 实例 dom 加载之后

⑤、beforeUpdate：数据更新之前

⑥、updated：数据更新之后

⑦、beforeDestroy：vue 实例销毁之前

⑧、destroyed：vue 实例销毁之后

**工作用的最多的是 created 和 mounted**

4、第一次啊加载页面会触发四个生命周期，分别是：

①、beforeCreate：vue 实例创建之前 -->可以在这个里面加 loading 事件加载动画

②、created：vue 实例创建之后 -->可以在这个里面加 loading 事件结束动画

③、beforeMount：vue 实例 dom 加载之前

④、mounted：vue 实例 dom 加载之后

### 十二、什么是计算属性 computed？什么是监听器 watch？两者的区别？使用场景？

1、计算属性：

①、计算属性是 vue 提供的基于数据驱动的，依赖其它数据计算得出的值。

2、监听器：

①、监听器是 vue 提供的基于数据驱动的，当某个数据变化时，执行相应的操作。

3、区别：

①、计算属性支持缓存，不支持异步，当计算属性中存在异步操作时，无法监听到数据的变化。

②、监听器不支持缓存，支持异步操作，可以监听到数据的变化，返回两个参数，第一个参数是新的值，第二个参数是旧的值。

4、使用场景：

①、计算属性使用场景：购物车商品数量计算总价

②、监听器使用场景：监听路由的变化，监听 id 发生变化的时候调接口

### ^十三、什么是过滤器？

1、过滤器就是在不改变原数据的情况下，对数据进行处理然后显示到页面上。就是在不破化原来数据的基础上生成一个新数据。

2、使用场景：处理时间戳。

### 十四、vue 中监听不到数据的变化怎么办？

1、监听不到数据变化的第一种情况：直接修改数据或者对象的值

解决办法：this.$set(要修改的数组/对象, 要修改的索引/属性, 要修改的值)

2、监听不到数据变化的第二种情况：数组长度为 0，清空数据

解决办法：直接赋值为空或者用 splice 删除

### 十五、请说一下父传子？子传父？父传子，子传父的传值方式？（组建的通讯方式有哪些？）

1、父传子：给子组件标签绑定一个自定义属性，到子组件内部通过 props 进行接收渲染数据。

2、子传父：子组件通过 this.$emit 发送数据，然后给子组件标签绑定一个自定义方法，值为接收参数的函数，函数接受的值就是子组件传递的参数。

3、祖辈传参：关联孙子和爷爷

```js
v - bind = "$attrs"
v - on = "$listeners"
```

4、后代传参：

发送数据：

```js
provide()
{
    return {
        name: '张三'
    }
}
```

接受数据：

```js
inject: ["name"];
```

### 十六、vue 组件为什么要 return 一下变量？为什么 data 是一个函数？

1、因为不使用 return 包裹数据，会在项目中变为全局可见，会造成变量的污染。使用 return 包裹后的数据，变量只能在当前组件中使用，不会影响其他组件。

2、为什么 data 是一个函数，因为组件可能被用来创建多个实例，当我们的 data 是一个函数的时候，每一个实例的 data 都是独立的，不会互相影响了。

### 十七、父子组件调用加载顺序？

1、组件调用的顺序都是先父后子。渲染完成的顺序都是先子后父。

2、组件销毁的顺序都是先父后子，销毁完成的顺序是先子后父。

### 十八、单页面开发与多页面开发的优缺点

1、单页面开发是指整个网站是由单个页面组成的；而多页面开发则是一个网站有多个页面。

2、单页面开发的优缺点：

优点：网站所有功能呈现于一整张页面中，用户体验较好，节省了用户时间，提高了用户的查找效率，对服务器请求较少，减轻了服务器的压力，只需要一次加载，维护成本较低。

缺点：网站功能复杂；网站优化相对困难；构建困难，需要单独的方案。

3、多页面开发的优缺点：

优点：多个页面之间跳转，用户可以清晰的了解整个网站的内容构成；实现简单，开发成本低。

缺点：页面跳转时，要重新执行 css、js 等文件页面片段之间跳转较慢，需要用到页面跨页面传值的几种方法，维护成本高。

### ^十九、怎么解决组件的样式污染？

在 CSS 中加入 scoped，然后深度监听一下，::v-deep 或者/deep/

### ^二十、为什么需要穿透 scoped？

UI 库看起来很美，但是，在很多项目中，会出现这么一种情况，即：引用了第三方组件，需要在组件中局部修改第三方组件的样式，而又不想去除
scoped 属性造成组件之间的样式污染（污染全局样式）。此时只能通过特殊的方式，穿透 scoped。

```css
<
style scoped >
外层 >>> 第三方组件 {
    样式
}

<
/
style >
```

通过 >>> 可以使得在使用 scoped 属性的情况下，穿透 scoped，修改其他组建的值。（注意：只作用于 css）

/deep/ 在 vue3 中会报错，如果/deep/报错，可采用 ::v-deep。（注意：只作用于 sass/scss/less）

### ^二十一、vue-router 有两种模式：hash 和 history 两种模式。

1、history 即地址栏没有#号。history 是最常用但是有 bug（vue 部署时使用这个模式刷新页面会报 404，配合后端修改路由刷新时的
bug）

2、hash 即地址栏有#，（vue 部署时刷新不会报 404，但是影响美观多了#）

### 二十二、非父子传参的方式

1、给 vue 的原型添加一个$observer挂载到main.js中，用this.$observer.$emit发送数据，用this.$observer.$on 接受数据。

2、vuex

### ^二十三、$router 与 $route 的区别？

1、$router 对象是全局路由的实例，里面有很多路由实例的方法。比如跳转方法 push、go、back...

2、$route l 是当前组件的路由信息。包括了 url 地址信息，当前的路径，路由传递的参数。

### 二十四、路由跳转方式，以及路由传值的方式。传值两种方式的区别？

1、路由跳转方式

①、router-link 中的 to 跳转

②、事件函数：this.$router.push({path})

2、路由跳转传值方式：

①、params 方式：通过路由的 name 进行传参，接收时通过 this.$route.params 接收

②、query 方式：通过路由 path 进行传参，接收时通过 this.$route.name 接收

3、区别：

①、params 传参不会显示在地址栏上，安全性高，并且页面刷新数据会丢失。解决办法：本地缓存起来。

②、query 传参会显示在地址栏上，并且页面刷新数据不会丢失。

### 二十五、什么是路由守卫？路由守卫有几种？路由中的钩子函数？

1、路由守卫：路由守卫又称导航守卫，指的是路由跳转前、中、后过程中的一些钩子函数。路由跳转前做一些验证，比如：登录验证，是网站中的普遍需求。

①、全局守卫：

beforeEach：路由进入之前，判断是否登录

afterEach：路由进入之后

②、局部守卫，组件内守卫有三种：

进入路由器前的验证，beforeRouteEnter -- 不能直接访问 this，需要 next 回调中获得

离开路由前的验证，beforeRouteLeava -- 可以直接访问 this

路由更新前的验证，beforeRouteUpdate

其中路由守卫钩子函数都有三个参数：

to：想去哪个路由

form：从哪个路由过来的

next：跳转到哪，执行跳转

③、路由独享守卫

beforeEnter 路由进入之前

### ^二十七、vue 怎样实现缓存？vue 项目列表跳转详情再返回列表还在原位置

1、keep-alive 缓存组件，有个 include 属性表示要缓存的组件名。

2、缓存组件有两个生命周期：组件打开时触发，组件离开时触发。
a

### ^二十八、vue 的混入？

vue 的混入将多个 vue 文件内重复使用的功能代码，提取成单个 js 文件，在需要使用的地方进行调用即可

### 二十九、知道 vuex 吗？vuex 有几种状态？分别是干什么的？

1、vuex 是一种最好的非父子传参方式，vuex 就是状态存储

2、有五种状态：

①、state：存储公共状态或者存储公共的数据

②、actions：用来处理异步数据

③、mutations：用来处理同步数据

④、gutters：计算属性

⑤、modules：导入 vuex 子模块

3、你用 vuex 做过什么东西？

左侧导航菜单

### 三十、vuex 的工作流程

当组件想要修改 state 里面的数据，首先需要调用 this.$store.dispatch 来触发 actions 里面的方法，在这个方法中会返回两个参数，一个是
commit 方法，一个是传递过来的值，然后在这个方法内部调用 commit 方法去触发 mutations 里面的函数，mutations 这个函数是专门修改存储
state 里面的数据，当 mutations 里面的函数触发后 state 里面的数据就会发生变化。就会存储到 state 中。

### 三十一、怎么给 vue 中 data 添加一个属性

1、对象中添加少量新属性，可以直接采用 Vue.set()

2、对象中添加多个新属性，则通过 Object.assign() 创建新对象

3、如果你实在不知道怎么操作时，可采用 $forceUpdate() 及性能强制刷新

### 三十二、vue 虚拟 dom？

通过 js 创建一个 Object 对象来模拟真实 DOM 结构，这个对象包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，通过
vue 中的 render() 函数把虚拟 dom 编译成真实 dom，在通过 appendChild() 添加到页面中。创建虚拟 DOM
就是为了更好将虚拟的节点渲染到页面视图中，为什么需要虚拟 DOM， DOM 是很慢的，虚拟 dom 用来解决频繁操作 dom 而引发的浏览器卡顿问题，vue
中虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 带来的性能消耗。

## Ⅳ、微信小程序

### 一、用过小程序吗？xxx 问题把你难住了？

用过，有些我忘了，因为做小程序项目的时候，基本上都是去看微信开发者文档。那么里面比较详细，框架里面的东西太多了记不住那么多。

### 二、小程序生命周期

onLoad：当页面显示时触发（接受一个参数），这个参数就是路由跳转过来的时候携带的参数，这个参数是对象。

onShow：监听页面显示

onHide：监听页面隐藏

onPullDownRefresh：监听用户下拉动作

onReachBottom：页面上拉触底事件的处理函数

onShareAppMessage：用户点击右上角分享

onUnload：监听页面卸载

onReady：监听页面初次渲染完成

### 三、小程序跳转

wx.navigateTo()：跳转到内页

wx.switchTab()：跳转到 tabbar 页面

### 四、获取数据变量

this.data.变量名

修改数据变量重新赋值的方法

this.setData({变量名: '修改的值'})

bindTap="函数名"

阻止事件冒泡: catchTap

data-参数名

会传入到事件对象里 e.currentTarget.dataset.参数名

### ^五、wx:if 与 hidden 区别 vue v-if/v-show 区别相同

wx:if 判断是否加载，可减轻浏览器压力，在需要的时候加载。

hidden 是否隐藏，hidden 改变的只是 display 的显示/隐藏样式

### 六、微信小程序记住下一次登录

在 app 全局中获取用户的 appid，然后拿着 appid，去获取用户信息。使用本地的数据缓存，将获取到的信息缓存起来，在需要的时候取出来，判断缓存中有数据就跳转到首页否则跳转到登录页面

### 七、小程序支付如何实现？

1、小程序注册，要以公司的身份去申请微信公众号及支付功能申请

2、绑定商户号，并且在小程序中填写合法域

3、wx.login 获取用户临时登录凭证 code，发送到后端服务器换取 openId 然后就可以用 token
去做一些登录判断，没授权的，先让他去授权，再存入缓存，有授权的，直接拿缓存

4、在下单时，小程序需要将购买的商品 Id，商品数量，以及用户的 openId 发送到服务器

5、调用微信支付 api，wx.requestPayment() 发起微信支付，唤醒支付工作台，进行支付，填写相应的签名等信息获取成功的回调即可支付成功

### 八、小程序的发布流程（开发流程）

1、注册微信小程序账号

2、获取微信小程序的 AppID

3、去微信公众平台配置域名

4、创建 demo 项目

5、代码上传

6、提交审核

7、小程序发布

## Ⅴ、uni-app

### 一、简单说一下 uni-app？

uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到
ios、adnroid、h5，以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台

### 二、uni-app 生命周期？

1、uni-app 应用的生命周期：

①、onLaunch：初始化完成时触发，全局只触发一次

②、onShow：当 uni-app 启动时，或从后台进入前台显示

③、onHide：当 uni-app 从前台进入后台

④、onError：当 uni-app 报错时触发

2、uni-app 页面的生命周期

①、onLoad：监听页面加载，参数为上个页面传递的参数，传递的类型为对象

②、onReady：监听页面首次渲染完成

③、onShow：监听页面显示

④、onHide：监听页面隐藏

⑤、onUnload：监听而页面卸载

⑥、onPullDownRefresh：监听用户下拉动作，一般用于下拉刷新

⑦、onReachBottom：页面滚动到底部的事件，上拉加载

### 三、uni-app 的优缺点

1、优点;

①、一套代码可以生成多端

②、学习成本低，语法是 vue 的，组件是小程序的

③、拓展能力强

④、使用 HBuilderX 开发，支持 vue 语法

⑤、突破了系统对 H5 调用原生能力的限制

2、缺点：

①、问世时间短，很多地方不完善

②、社区不大

③、官方对问题的反馈不及时

④、在 Android 平台上比微信小程序和 ios 差

⑤、文件命名受限

### 四、小程序、uni-app 中的本地数据存储和接收？

1、微信小程序：

存储：通过 wx.setStorage/wx.setStorageSync 写数据到缓存

接收：通过 wx.getStorage/wx.getStorageSync 读取本地缓存

2、uni-app：

存储：uni.setStorage({key: "属性名",data:"值"})

接收：uni.getStorage({key: "属性名", success(res){res.data}})

### 五、简述 rpx、px、em、rem、%、vh、vw 的区别

1、rpx：相当于把屏幕分成 750 份，1 份就是 1rpx，100rpx = 50px

2、px：绝对单位，页面按精确像素展示

3、em：相对单位，相对于它的父节点字体进行计算

4、rem：相对单位，相对根节点 html 的字体大小来计算

5、%：一般来说就是相对于父元素

6、vh：视窗高度，1vh 等于视窗高度的 1%

7、vw：视窗宽度，1vw 等于视窗宽度的 1%

### 六、js、vue、uni-app、小程序的页面传参方式区别

1、js 传参

通过 url 拼接参数进行传参

接收通过 location.href

2、vue 传参

vue 可以通过标签 router-link 跳转传参

也可以通过事件里的 this.$router.push({}) 跳转传参，传参有两种 params 和 query

接收 this.$route.params、this.$route.query 接收

3、小程序传参

通过跳转路径后面拼接参数来进行跳转传参

### 七、uni-app 解决跨端兼容问题？

```html
<!-- #ifdef H5 -->
代码只在 H5 显示
<!-- #endif -->

<!-- #ifdef MP-WEIXIN -->
代码只在微信小程序显示
<!-- #endif -->
```

### 八、uni-app 适配刘海屏

https://www.cnblogs.com/moranjl/p/15739275.html

## Ⅵ、Vue3.0

### ^一、vue3.0 的响应式原理

vue3 是通过 es6 语法中的 proxy 把目标对象变成代理对象，然后通过 Reflect 把值返回回来的操作，将数据变成响应式

### ^二、vue3 的生命周期有几个？与 vue2 生命周期的区别？

vue2 的生命周期有八个，vue3 的生命周期有六个

因为 vue3.0 的 beforeCreate 和 created 被 setup 替代了

### 三、组合式 api 方法？

1、ref：定义一个基础数据类型的数据响应式

2、reactive：定义一个复杂复合型数据类型的数据响应式

3、watch：数据监听

4、computed：计算属性

5、toRefs：是将 reactive 的响应式对象中的所有属性转换为单独的响应式数据，对象成为普通对象，并且值是关联的

6、toRef：把响应式数据对象中的某个属性变成了 ref 对象

### 四、vue3.0 优点？

1、速度更快，vue3 相比 vue2，重写了虚拟 Dom 实现，编译模板的优化，更高效的组件初始化

2、体积更小，灵活的逻辑组合与复用，如 ref、reactive、computed 等，仅仅在用到的时候才打包，去掉了没用到的模块

3、更易维护，灵活的逻辑组合与复用，更好的 Typescript 支持 Vue3 组件现在支持有多个根节点，瞬移 Teleport 等功能

### 五、vue2.0 和 3.0 区别

1、生命周期，beforeCreate 和 created 于 setup 合并

2、多根节点，内部会将多个标签包含在一个 Fragment 虚拟元素中

3、采用组合式 API，可将同一逻辑的内容写到一起，增强了代码的可读性、内聚性，复用性

4、提供 Suspense 异步组件，允许程序在等待异步组件加载完成前渲染

5、提供 Teleport 瞬移组件可将部分 DOM 移动到 Vue.app 之外的位置。

6、响应式原理不同，Vue2 响应式原理基础是 Object.defineProperty；Vue3 响应式原理基础是 Proxy。

7、支持 TypeScript

### 六、Vue3.0 所采用的 CompositionApi 与 Vue2.x 使用的 OptionsApi 有什么区别？

1、代码更利于维护和封装

2、Vue2 中,我们会在一个 vue 文件的 data，methods，computed，watch 中定义属性和方法，共同处理页面逻辑，一个功能的实现，代码过于分散

3、vue3 中，代码是根据逻辑功能来组织的，一个功能的所有 api 会放在一起（高内聚，低耦合），提高可读性和可维护性，基于函数组合的
API 更好的重用逻辑代码

4、Vue3 中用 setup 函数代替了 Vue2 中的 beforeCreate 和 created

5、Vue3 中用 onUnmounted 代替了 Vue2 中的 beforeDestroy

6、Vue3 中用 unmounted 代替了 Vue2 中的 destroyed

### 七、了解 hook 函数吗？

相当于 vue2 的混入，将公共代码封装出去

### 八、v-if 与 v-for 在 vue3.0 中的变化？

1、在 vue2.0 和 vue3.0 中不倡议在同一元素应用 v-for 和 v-if

2、在 vue3.0 中 v-if 优先级比 v-for 高，vue2.0 中 v-for 优先级比 v-if 高

## Ⅶ、TypeScript

### 一、ts 中的数据类型有哪些？

string，number，undefined，null，boolean，any，元组，枚举，void，object

### 二、什么是联合类型？什么是元组？什么是枚举？什么是接口？什么是泛型？

1、联合类型：联合类型可以通过 | 联合成一个整体。表示赋值可以为多种类型中的一种

2、any：表示任意类型，用来存储不确定的类型数据

3、元组类型：元组类型允许表示一个已知元素的数量和类型的数组

4、枚举类型：是 ts 中的一种基本数据类型，并且分为数字枚举、字符串枚举、复合型枚举。其中数字枚举编号默认是从 0 开始,依次 +1
递增，其中编号是可以修改的，字符串枚举必须初始化

5、接口：就是为对象添加类型注解，用来约束对象的结构

6、泛型：指的在定义函数或者接口的时候，不预先指定具体的类型，而是在使用的时候再去指定数据类型

## Ⅷ、项目必问

### 一、介绍一个你比较熟悉的项目，业务流程，主要问以下内容

记叙文的六要素：时间、人物、地点、起因、经过、结果；

时间：研发周期；

人物：团队成员、分工、我负责哪几个模块；

起因：项目背景、项目的用户是谁、用户能用这个 App 干啥、基本业务逻辑描述；

经过：负责哪几个模块，主用的技术栈是…，

结果：耗时多久上线、目前处于何种状态；

项目亮点：最好有并且输出 10 分钟；

业务流程：逻辑必须清楚

后期优化

### 二、项目中遇到的难点？如何解决的？

csdn

程序猿

技术博客论坛

稀土掘金

### 三、设计图网站，项目管理工具？

设计图网站：蓝湖或者墨刀，一般在蓝湖下载 ui 设计的图片

项目管理工具：

禅道，用于日常提交 bug

git 项目的版本更新迭代

### 四、git 基本的指令有哪些？如何解决冲突？

`git clone`

`git pull`

`git add .`

`git commit -m"提交的信息"`

`git push`

`git checkout -b 子分支名称`

`git push origin 子分支名称 `

`git branch -a `

`git checkout 分支名称等等`

合并代码或者解决冲突一般使用可视化工具：小乌龟/svn

合并代码

第一步在 ceshi 子分支，然后拉取 ceshi 子分支上面的最新的代码,确保测试分支上没有可以提交的代码。

第二步合并分支必须在主分支上，所以切换到 master 分支上,先拉取最新的代码，然后右键点击小乌龟-合并，选择从哪个分支合并到
master，点击确定，最后点击右键小乌龟-推送，即可实现合并代码.

解决冲突

两个人在同一个分支上改同一行代码。

甲提交了代码，乙没有拉取代码也提交了代码，再一次拉取的时候，会产生冲突。
（或者你在拉取代码代码之后还没来得及提交，别人已经在你的分支上上传了一个新的代码）

解决办法：右键小乌龟-解决冲突。选择正确的代码右键选择使用此文件块，然后右键提交代码

### 五、你的项目中，是如何实现登录功能的？（token 令牌，如何管理接口权限？）

实现登录功能，最核心的技术是 JWT（也就是 token）。我们通过 token 来记录用户的登录状态。并把 token 存储到 vuex 中或者浏览器缓存中。

首先，我们调用登录的 API 接口，把用户填写的表单信息发送给后端，后端校验通过之后，会返回一个 token 字符串，里面记录了用户的基本信息。然后我们将
token 存储到 vuex 中或者浏览器缓存中。

如果我们使用的是 vuex，那么页面一刷新，状态就丢失了。因此，我们通过 vuex-persistedstate 这个插件，可以把 vuex
中的所有数据，持久化存储到本地。

然后，用户在调用接口的时候，我们会通过 axios 的请求拦截器，将 token 放到请求头中的这样，有权限的接口才能调用成功。

如果 token 过期了，会触发 axios 的响应拦截器。通过 err.response.status 可以判断响应状态码是否为 401，如果是，则证明 token
过期了，我们需要清空 vuex 中的数据。并通过路由的编程式导航 API，跳转到 login 登录页面，让用户重新进行登录。

### 六、在项目中如何使用 axios？

1 axios 在项目中，主要用来发起 Ajax 的数据请求，专门用来实现前后端数据交互的。

2 我们在项目中会对 axios 做进一步的封装。会创建一个 src/utils/request.js 的模块，里面调用 axios.create() 函数，来创建 axios
的实例对象。在调用 create 函数期间可以全局配置请求的 baseURL 根路径等。

3 对于功能类似的 API 接口，我们会在 src/api 目录下进行接口的封装。这样可以提高 API 接口的复用性。
在项目中还会用到 axios 的拦截器。它主要的应用场景是： a. 基于请求拦截器展示 loading 提示，基于响应拦截器隐藏 loading 提示

4 基于请求拦截器，为有权限的接口统一添加 Authorization 的 token 认证 c. 基于响应拦截器，判断响应状态码是否为 401，来处理
token 失效后的问题

### 七、项目流程

1、项目立项；

2、BA（business analyst 一般指产品经理）整理项目需求，定项目周期；

3、需求评审会（过项目需求）；

4、后端设计数据库，ui 设计原型图；

5、ui 评审；

6、前端静态页面开发（mock 数据测试），后端做接口，测试做测试用例；

7、前后端联调；

8、测试；

9、项目上线；

